# -*- coding: utf-8 -*-
"""Solução_da_TOV_com_npArray_e_valores_ajustados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MTQUMUZwSAmtMFxB7BTYNAgapZQzLR5h

$$
\begin{cases}
\dfrac{dP}{dr}=-\dfrac{G\rho(r)m(r)}{r^2}\left(1+\dfrac{P(r)}{\rho(r)\cdot c^2}\right)\left(1+\dfrac{4\pi r^3P(r)}{m(r)c^2}\right)\left(1-\dfrac{2Gm(r)}{c^2r}\right)^{-1}\\
\dfrac{dm}{dr}=4\pi\cdot \rho \cdot r^2\\
P=k\cdot \rho^{\gamma}
\end{cases}
$$

Derivando a terceira equação em função de $r$ encontramos
$$\dfrac{dP}{dr}=γk\rho^{γ-1}\cdot \dfrac{d\rho}{dr}$$

Aplicando na primeira equação alcançamos um novo sistema de equações diferenciais.

$$\begin{cases}
\dfrac{d\rho}{dr}=-\dfrac{G\cdot m\cdot \rho^{2-γ}}{γk\cdot r^2}\left(1+\dfrac{k\cdot \rho^{\gamma-1}}{c^2}\right)\left(1+\dfrac{4\pi r^3k\cdot \rho^{\gamma}}{m\cdot c^2}\right)\left(1-\dfrac{2Gm}{c^2r}\right)^{-1}\\
\dfrac{dm}{dr}=4\pi \cdot ρ⋅ r^2
\end{cases}$$

Para o caso da solução relativística da equação de estado encontramos $\gamma=4/3$.

Temos um sistema de equações diferenciais acopladas em função de $r$ dadas por:
$$\begin{cases}
m'=f_1(r,m,\rho)\\
\rho'=f_2(r,m,\rho)
\end{cases}$$

Definiremos algumas constantes físicas que serão utilizadas ao decorrer do programa.
"""

import numpy as np

# Constante de Planck reduzida
h = 1.055*(10**(-27))

# pi
pi = np.pi

# Velocidade da luz no vácuo
c = 29979245800

# Massa do elétron
me = 9.109*(10**(-28))

#massa do núcleon
## mn = 2.676*(10**(-26))
mn = 1.660538731e-24


#razão entre a massa atômica e o número atômico
eta = 2

# Constante universal da gravitação
G = 6.67*(10**(-8))

# Massa do sol
M_sun = 1.98892*(10**33)

# gamma
gamma = 4/3

"""O valor de $k$ depende das constantes físicas.
$$k=\dfrac{\hbar c}{12\pi^2}⋅\left(\dfrac{3\pi^2}{m_n\cdot \eta}\right)^{\frac{4}{3}}$$
"""

k = ((h*c)/(12*pi*pi))*((3*pi*pi)/(mn*eta))**(4/3)

"""Definindo algumas funções Auxiliares.
$$\textbf{aux}_1=1+\dfrac{k\cdot \rho^{\gamma-1}}{c^2}$$
"""

def aux1(r,m,rho):
    return 1.+(k*(rho**(gamma-1)))/(c**2)

"""$$\textbf{aux}_2=1+\dfrac{4\pi r^3k\cdot \rho^{\gamma}}{m\cdot c^2}$$"""

def aux2(r, m, rho):
    return 1.+(4*pi*(r**3)*k*(rho**gamma))/(m*c**2)

"""$$\textbf{aux}_3=\left(1-\dfrac{2Gm}{c^2r}\right)^{-1}$$"""

def aux3(r, m, rho):
    return (1-(2*G*m)/(r*c*c))**(-1)

"""Definindo as funções $f_1$ e $f_2$."""

def f1(r, y: np.array):
    return 4*pi*y[1]*r*r

def f2(r, y: np.array):
    return -(G*y[0]*(y[1]**(2-gamma)))/(gamma*k*(r**2))*aux1(r,y[0],y[1])*aux2(r,y[0],y[1])*aux3(r,y[0],y[1])

"""**Sistema de equações difierenciais**

Um sistema de equações diferenciais do tipo

$$\begin{cases}
y_1'=f_1(x, y_1, y_2, \ldots, y_n) \\
y_2'=f_2(x, y_1, y_2, \ldots, y_n) \\
\,\,\,\,\,\,\,\,\vdots \\
y_n'=f_n(x, y_1, y_2, \ldots, y_n)
\end{cases}$$

pode ser escrito resumidamente da forma

$$\textbf{y'}=\textbf{f}(x,\textbf{y})$$

Em que $x\in \mathbb{R}$ e

$$\textbf{y}=\left[
\begin{array}{ccc}
y_1\\
y_2\\
\vdots\\
y_n
\end{array}
\right]\,\,\,\,e\,\,\,\,
\textbf{f}(x,\textbf{y}) =\left[
\begin{array}{ccc}
f_1(x,\textbf{y})\\
f_2(x,\textbf{y})\\
\vdots\\
f_n(x,\textbf{y})
\end{array}
\right]
$$

São vetores em $\mathbb{R}^n$.

O métodode Runge-Kutta para esse sistema vetorial é

$$\textbf{y}_{n+1}=\textbf{y}_n+\dfrac{h}{6}(\textbf{k}_1+2\textbf{k}_2+2\textbf{k}_3+\textbf{k}_4)$$

Onde
$$\begin{cases}
\textbf{k}_1=\textbf{f}(x_n, \textbf{y}_n)\\
\textbf{k}_2=\textbf{f}\left(x_n +\dfrac{h}{2}, \textbf{y}_n+\dfrac{h}{2}\cdot \textbf{k}_1\right)\\
\textbf{k}_3=\textbf{f}\left(x_n +\dfrac{h}{2}, \textbf{y}_n+\dfrac{h}{2}\cdot \textbf{k}_2\right)\\
\textbf{k}_4=\textbf{f}(x_n +h, \textbf{y}_n+h\cdot \textbf{k}_3)
\end{cases}$$

Definiremos a tupla $f$ com os valores das duas funções.
"""

def f(r, array: np.array):
    return np.array([f1(r,array), f2(r,array)])

"""As condições iniciais do sistema serão definidas com as condições do núcleo da anã branca.

$$\begin{cases}
r_o=0.00000001\,m\\
m_o=0\\
\rho_o=2\cdot 10^{17}\,kg/m^3
\end{cases}$$

iremos analisar os valores de raio até $10000\,km$
"""

r = [0.0001]

### y=[(m_0, rho_0)]
y = [np.array([0.0001, 2*10**(9)])]

ini = r[0]
fim = 1000000000
n = 100000

"""Definindo o passo para $n$ intervalos."""

def H(ini, fim, n):
    return (fim-ini)/n

"""Definindo os 4 $k's$ do método de Range Kutta de 4ª ordem."""

def k1(r, y: np.array, h):
    return f(r,y)

def k2(r, y: np.array, h):
    k_aux = k1(r,y,h)
    return f(r+h/2,y + (h/2)*k_aux)

def k3(x, y, h):
    k_aux = k2(x,y,h)
    return f(x+h/2,y + (h/2)*k_aux)

def k4(x, y, h):
    k_aux = k3(x,y,h)
    return f(x+h, y + h*k_aux)

"""Preenchendo os valores dentro das listas e plotando o gráfico."""

import matplotlib.pyplot as plt

def RK_4(ini, fim, n):
    h = H(ini, fim, n)

    for i in range(n):
        r.append(r[i]+h)

        aux = (h/6)*(k1(r[i], y[i], h) + 2* k2(r[i], y[i], h) + 2*k3(r[i], y[i], h) + k4(r[i], y[i], h))
        aux0 = (h/6)*(k1(r[i],y[i],h)[0]+2*k2(r[i],y[i],h)[0]+2*k3(r[i],y[i],h)[0]+2*k4(r[i],y[i],h)[0])
        aux1 = (h/6)*(k1(r[i],y[i],h)[1]+2*k2(r[i],y[i],h)[1]+2*k3(r[i],y[i],h)[1]+2*k4(r[i],y[i],h)[1])

        y.append(y[i] + aux)

    massa = [m[0]/M_sun for m in y]

    plt.style.use('ggplot')
    fig, ax = plt.subplots()
    ax.plot([raio/10000 for raio in r], massa)

    ax.set_title('Gráfico de $M$ em função de $r$')
    ax.set_xlabel('$r(km)$')
    ax.set_ylabel('$M/M_{\odot}$')


    ax.legend()

    plt.show()

RK_4(ini, fim, n)